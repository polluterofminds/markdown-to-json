#!/usr/bin/env node
// vi: ft=javascript
/* eslint-env node */
'use strict';

const program = require('commander');
const R = require('ramda');
const fs = require('fs');

const m2j = require('..'); // looks for "main" in ../package.json

program
    .version(require('../package.json').version)
    .usage('[options] <files>')
    .option('-w --width <int>',
        'max width of preview text [70]. Set to 0 for no preview',
        Number, 70)
    .option('-m --minify', 'format JSON without newlines')
    .option('-c --content', 'include full content')
    .option('-o --outfile <filename>', 'filename to save json to [output.json]')
    .parse(process.argv);

const options = {
  minify: program.minify,
  width: program.width,
  outfile: program.outfile,
  content: program.content,
};

// If there's no list of files to process, print usage and quit immediately
if (!program.args.length) {
  program.help();
}


program.args = ["error", "test/fixtures/bellflower.md", "test"]

const classifyDirectory = R.curry((suffix, path) => fs.lstatSync(path).isDirectory() ? `${path}${suffix}` : path );

const safeExists = (arg) => {
  try {
    fs.lstatSync(arg);
    return true;
  } catch (e) {
    return false;
  }
};

// Pipeline, filter, map, currying

const clog = R.curry((phrase, val) => console.log(`${phrase || 'clog'}`, val));

const allFileNames = R.pipe(
  R.filter(safeExists),
  // R.tap(console.log),
  R.tap(clog('so far so good:')),
  R.map(classifyDirectory('/')),
)(program.args);

console.log('done', allFileNames);


process.exit(5);

// with Ben
const getFiles = function(filename) {
  if (fs.lstatSync(filename).isDirectory()) {
    return fs.readdirSync(filename).filter((entry) => !entry.isDirectory);
  } else {
    return [filename];
  }
};

const parseAllTheFiles = {};

const files = filenames
    .map(getFiles)
    .reduce((collection, filenames) => collection.concat(filenames), []);

files
    .map((file) => processFile(file, options.width, options.content))
    .forEach((data) => {
      parseAllTheFiles[data.basename] = data.metadata;
    });


const output = m2j.parse(program.args, options);
if (output) {
  process.stdout.write(output);
}
